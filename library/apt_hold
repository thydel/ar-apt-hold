#!/usr/bin/python

DOCUMENTATION = '''
---
module: apt_hold

short_description: Manages aptitude search pattern to hold or unhold packages

description: |
     The M(apt_hold) module the get list of currently held packages,
     then search for a list of packages matching aptitude search patterns
     and depending of hold option will either
     hold found packages not already held
     or unhold found packages currently held.
     M(apt_hold) set C(apt_hold) dict facts to contains the list of C(held) packages,
     C(found) packages mathing C(search)
     and C(diff) packages to be hold or unhold if any.

options:

  search:
    description: |
      An argument to aptitude search to get the list of packages to hold or unhold
      that can be either a string or a list of string.
      When no C(search) string is given M(apt_hold) will still set facts for held packages.
    required: false
    default: null

  hold:
    description: Whether to hold or unhold the found packages.
    required: false
    choices: [ "yes", "no" ]
    default: null

  notfoundok:
    description: |
      Whether it is an error or not to I(hold) or I(unhold) an empty I(found) list of packages
    required: false
    choices: [ "yes", "no" ]
    default: "no"

notes: []
requirements: [ "aptitude" ]
author: Thierry Delamare
...
'''

EXAMPLES = '''
# set the list of held packages as fact in apt_hold
- apt_hold:
- debug: var=apt_hold

# hold not yet held packages from a search string
- apt_hold: hold=True search="?and(?maintainer(epiconcept), ?installed)"

# - use an extra variable to toggle hold state
# - use a list of search string
# - use an extra variable to toggle show facts
- apt_hold:
    hold: |
      {{ hold | default('yes') }}
    search:
      - ?and(?maintainer(epiconcept), ?installed)
      - ~i^percona-xtrabackup$
- debug: var=apt_hold
  when: show is defined and show|int
'''

def main():
    
    argument_spec = dict(
        hold = dict(required=False, choices=BOOLEANS, type='bool', default=True),
        search = dict(required=False, type='list', default=[]),
        notfoundok = dict(required=False, choices=BOOLEANS, type='bool', default=False),
        )

    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)

    changed = False
    info = {}
    ansible_facts = { 'apt_hold': info }

    def getargs(arg):
        info[arg] = globals()[arg] = module.params.get(arg)
        
    # all(map(getargs, argument_spec.keys()))
    for arg in argument_spec.keys():
        getargs(arg)

    if (len(search) == 1 and search[0] == ''):
        del search[0]

    cmd_apt                 = ["/usr/bin/env", "aptitude"]
    cmd_search = cmd_apt    + ["--disable-columns", "-F", "%p", "search"]

    cmd_held   = cmd_search + ["~ahold"]
    cmd_find   = cmd_search + search

    cmd_hold   = cmd_apt    + ["hold"]
    cmd_unhold = cmd_apt    + ["unhold"]

    # get the list of held packages

    rc, out, err = module.run_command(cmd_held, check_rc=True)
    held = out.split()
    info['held'] = held

    # find a list of packages

    found = []
    if search:
        rc, out, err = module.run_command(cmd_find, check_rc=True)
        found = out.split()
        info['found'] = found

    # if no hold arg return facts
    
    if hold is None or (not found and notfoundok):
        module.exit_json(changed=changed, ansible_facts=ansible_facts)

    # either hold or unhold found packages

    if not found:
        module.fail_json(msg="Can't hold or unhold an empty packages list")
        
    if hold:
        cmd = cmd_hold
        diff = sorted(list(set(found).difference(held)))
    else:
        cmd = cmd_unhold
        diff = sorted(list(set(found).intersection(held)))

    if diff:
        changed = True
        info['diff'] = diff
        if module.check_mode:
            module.exit_json(changed=changed, ansible_facts=ansible_facts)
        rc, out, err = module.run_command(cmd + diff, check_rc=True)

    module.exit_json(changed=changed, ansible_facts=ansible_facts)

from ansible.module_utils.basic import *

main()
